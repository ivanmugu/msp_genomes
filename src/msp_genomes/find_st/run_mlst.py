"""Run mlst."""

from argparse import Namespace
from pathlib import Path
import pandas as pd
from pandas import DataFrame
import json

from msp_genomes.find_st.mlst import mlst_runner
from msp_genomes.utils.get_cli import parse_command_line_input
from msp_genomes.utils.miscellaneous import (
    get_assemblies_info,
    make_output_folders,
    clear_folder,
    log_writer,
    compile_info_from_assemblies_into_dataframe,
)
import msp_genomes.utils.config as config

_cge_script_name = "mlst"
_output_mlst_file = "data.json"

# = Arguments to run mlst ===============================================================
DATABASE = config.MLST_DB
TMP_DIR = config.TMP_DIR
METHOD_PATH = None
EXTENDED_OUTPUT = True
QUIET = False
KMA_MATRIX = False
SAVE_TMP = False
DEPTH = 5.0
# =======================================================================================


def make_argparser_for_mlst(
    infile: Path = Path("."), outdir: Path = Path("."), species: str = None
) -> Namespace:
    args = Namespace()
    args.infile = infile
    args.outdir = outdir
    args.species = species
    args.database = DATABASE
    args.tmp_dir = TMP_DIR
    args.method_path = METHOD_PATH
    args.extented_output = EXTENDED_OUTPUT
    args.quiet = QUIET
    args.kma_matrix = KMA_MATRIX
    args.save_tmp = SAVE_TMP
    args.depth = DEPTH
    return args


def get_species_db_name(config_mlst_file: Path = config.MLST_CONFIG) -> dict:
    """Make a dictionary to match species name and species_db to run mlst.

    In the case of more than one schema database, this funtion makes a dictionary with
    only the first schema. For example, mlst can give the st of E. coli using two
    schemas. The names of the databases for these schemas are 'ecoli' and 'ecoli_2'. The
    key-value in the return dictionary is 'Escherichia coli': 'ecoli'. The second schema
    is ignored.
    """
    with open(config_mlst_file, "r") as f:
        species_db = {}
        for line in f:
            if line[0] == "#":
                continue
            row = line.split("\t")
            name = row[1]
            # Check if name has `#`
            if "#" in name:
                name = name.split("#")
                name = name[0]
            if name in species_db:
                continue
            species_db[name] = row[0]
    return species_db


def mlst_wrapper(
    assemblies_info: dict,
    args_mlst: Namespace,
    species_db_names: dict,
    compilation_output: Path,
) -> None:
    """Run mslt using the assembly.fasta files generated by Unicycler."""
    # Make output folders to store mlst results.
    make_output_folders(assemblies_info)
    # Run mlst on each assembly.
    for key, value in assemblies_info.items():
        print(value)
        # I have to convert assembly_path and output_folder to str because mlst doesn't
        # like Path. Also, the assembly_path should be given as list.
        args_mlst.infile = [str(value["assembly_path"])]
        args_mlst.outdir = str(value["output_folder"])
        species = value.get("species")
        if not species or (species == "Not found"):
            print(f"`{key}` doesn't have species")
            log_writer(f"mlst: `{key}` doesn't have species\n", compilation_output)
            continue
        if not (db_name := species_db_names.get(species)):
            print(f"No schema for `{key}` -> `species {species}`")
            log_writer(
                f"mlst: no schema for `{key}` -> `species {species}`\n",
                compilation_output,
            )
            continue
        else:
            args_mlst.species = db_name
        mlst_runner(args_mlst)


def compile_mlst_results_into_dataframe(strains_info: dict) -> DataFrame:
    """Compile mlst results from folders into a DataFrame."""
    results = {}  # To compile information
    counter = 0  # To use it as keys in results. It will help to make the DataFrame
    # Iterate over mlst results files to compile the information.
    for strain, info in strains_info.items():
        # Check if output folder has mlst results.
        data_json = info["output_folder"] / _output_mlst_file
        if not (data_json.exists()):
            continue
        # Get sequence type (st)
        with open(data_json, "r") as f:
            mlst_results = json.load(f)
        st = mlst_results["mlst"]["results"]["sequence_type"]
        results[counter] = {"Isolate ID": strain, "ST": st}
        counter += 1
    # Convert results into a DataFrame
    results = pd.DataFrame.from_dict(results, orient="index")

    return results


def find_st(cli: dict) -> None:
    # Create Namespace to run mlst
    args = make_argparser_for_mlst()
    args.infile = cli["input_folder"]
    args.outdir = cli["output_folder"]
    # Get information to run mlst and compile the results.
    strains_info = get_assemblies_info(
        cli["input_folder"],
        cli["output_folder"],
        cli["compilation_output"],
        _cge_script_name,
    )

    # Get species db names from the mlst config file
    species_db_names = get_species_db_name()

    # Run mlst
    mlst_wrapper(strains_info, args, species_db_names, cli["compilation_output"])

    # Clear tmp folder
    clear_folder(TMP_DIR)

    # compile mlst results
    compiled_results = compile_mlst_results_into_dataframe(strains_info)

    # Compile info from the assembly files into a DataFrame.
    df_assemblies = compile_info_from_assemblies_into_dataframe(cli["input_folder"])
    df_assemblies.sort_values(
        by=["Isolate ID", "Molecule size"], ascending=[True, False]
    )

    # Merge DataFrames.
    merged_df = pd.merge(df_assemblies, compiled_results, on=["Isolate ID"], how="left")

    # Export DataFrame as Excel file.
    merged_df.to_excel(
        cli["compilation_output"] / config.OUTPUT_NAMES_COMPILATIONS["mlst"],
        index=False,
    )
    print(merged_df)


if __name__ == "__main__":
    cli = parse_command_line_input(_cge_script_name)
    strains_info = get_assemblies_info(
        cli["input_folder"],
        cli["output_folder"],
        cli["compilation_output"],
        _cge_script_name,
    )
    results = compile_mlst_results_into_dataframe(strains_info)
    print(results)
