"""Get command line input."""

import argparse
from argparse import Namespace
from pathlib import Path
import sys


def parse_command_line_input(script_name: str) -> dict:
    """Parse command line input and retrun a dictionary.

    Return example:
        {
            'input_folder': PosixPath('~/Documents/assemblies'),
            'output_folder': PosixPath('~/Documents/results'),
            'compilation_output': PosixPath('~/Documents/results')
        }
    """
    # Create parser
    parser = argparse.ArgumentParser(
        add_help=False,
        prog=f"{script_name}",
        formatter_class=argparse.RawTextHelpFormatter,
        description=(
            f"Run {script_name} iterating over folders with assemblies generated by\n"
            "the LMB-lab-Unicycler pipeline."
        ),
        epilog=(
            "This program works using assemblies generated by unicycler in the\n"
            "following tree structure.\n\n"
            "assemblies/\n"
            "├── SW0001/\n"
            "│   └── assembly.fasta\n"
            "└── SW0002/\n"
            "    └── assembly.fasta\n"
        ),
    )
    # Make the argument groups.
    helper = parser.add_argument_group("Help")
    required = parser.add_argument_group("Required")
    optional = parser.add_argument_group("Optional")
    # Help arguments
    helper.add_argument("-h", "--help", action="help", help="Show this help and exit.")
    # Required arguments
    required.add_argument("-i", "--input", required=True, help="Path to input folder.")
    # Optional arguments
    optional.add_argument(
        "-o",
        "--output",
        help="Path to output folder.\nDefault: path to input folder.",
    )
    optional.add_argument(
        "-c",
        "--compilation-output",
        help=(
            f"Path to save {script_name} compilation.\nDefault: path to output folder."
        ),
    )
    optional.add_argument(
        "-e",
        "--extended-output",
        action="store_true",
        help="Save all output generated by the script(s).",
    )
    # Parse command line arguments
    command_line_info = parser.parse_args()
    # Get command line arguments
    user_input = store_command_line_arguments(command_line_info)

    return user_input


def store_command_line_arguments(command_line_info: Namespace) -> dict:
    """Check and store command line input into a dictionary"""
    user_input = {}

    # Check input folder
    input_folder = Path(command_line_info.input)
    if not input_folder.is_dir():
        sys.exit(f"Error: `{input_folder}` is not a directory")
    else:
        user_input["input_folder"] = input_folder

    # Check output folder
    output_folder = command_line_info.output
    if not output_folder:
        user_input["output_folder"] = input_folder
    elif not Path(output_folder).is_dir():
        sys.exit(f"Error: `{output_folder}` is not a directory")
    else:
        user_input["output_folder"] = Path(output_folder)

    # Check resfinder compilation folder
    compilation_folder = command_line_info.compilation_output
    if not compilation_folder and output_folder:
        user_input["compilation_output"] = Path(output_folder)
    elif not compilation_folder and not output_folder:
        user_input["compilation_output"] = Path(input_folder)
    elif not Path(compilation_folder).is_dir():
        sys.exit(f"Error: `{compilation_folder}` is not a directory")
    else:
        user_input["compilation_output"] = Path(compilation_folder)

    # Check if user wants extended output
    user_input["extended_output"] = command_line_info.extended_output

    return user_input
